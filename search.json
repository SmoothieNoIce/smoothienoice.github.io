[{"title":"srlabs/Certiception 安裝教學","url":"/2024/07/23/2024-07-23-Certiception/","content":"\n白皮書: “[*Certified Pre-Owned: Abusing Active Directory Certificate Services](https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf)”*\n\n[https://tttang.com/archive/1593/#toc_061-misconfigured-certificate-templates-esc1](https://tttang.com/archive/1593/#toc_061-misconfigured-certificate-templates-esc1)\n\n# Certiception\n\nReference:\n\n- [https://www.gss.com.tw/blog/ansible-5](https://www.gss.com.tw/blog/ansible-5)\n- [https://medium.com/ianyc/ansible-windows連線設定-basic-certificate-authentication-6750611d3764](https://medium.com/ianyc/ansible-windows%E9%80%A3%E7%B7%9A%E8%A8%AD%E5%AE%9A-basic-certificate-authentication-6750611d3764)\n\n本專案使用 Ansible，需要一台 linux 的 controller 及一台被操作的 windows server\n\n1. windows 安裝 winrm\n    - 可於[連結](https://docs.ansible.com/ansible/latest/os_guide/windows_setup.html#winrm-listener)下載 powershell script 檔，然後在需要被安裝的 windows host 上執行安裝 winrm\n2. 設定 Certiception\n    - 在 controller 上下載\n        \n        [https://github.com/srlabs/Certiception](https://github.com/srlabs/Certiception)\n        \n    - 安裝 ansible\n        \n        [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)\n        \n        ```jsx\n        $ python3 -m pip install --user ansible\n        ```\n        \n3. 在 windows 建立 Enterprise Admin account\n    - 創建名稱為 `Vagrant` 的 `Enterprise Admin account`，並根據資料在 controller 內編輯專案裡面的 inventory.yml\n    \n    <aside>\n    💡 創建 Vagrant EA 的截圖，需要在創建 User 完後加進 Group 內\n    \n    ![Untitled](Untitled%203.png)\n    \n    </aside>\n    \n    <aside>\n    💡 創建 Enterprise Admin account 時，如果遇到密碼不符合時，可修改 policy\n    \n    ![Untitled](Untitled%204.png)\n    \n    ![Untitled](Untitled%205.png)\n    \n    ![Untitled](Untitled%206.png)\n    \n    </aside>\n    \n4. 執行 Ansible 指令\n    \n    <aside>\n    💡 安裝前要注意不能有 ADCS，因為 ansible 會幫你裝好\n    \n    </aside>\n    \n    ```bash\n    ansible-playbook -i inventory.yml playbooks/certiception.yml -vvv\n    ```\n    \n    <aside>\n    💡 Please provide the password for the configured Enterprise Admin account (needed to register the new CA):\n    為 Vagrant 的密碼\n    \n    </aside>\n    \n    <aside>\n    💡 Please provide the password for the become user (local admin) on the honeypot CA server\n    為 local admin(Administrator)的密碼\n    \n    </aside>\n    \n    ![Untitled](Untitled%207.png)\n    \n    如果沒遇到錯誤就是安裝成功\n    \n    <aside>\n    💡 Exception calling \"CreateProcessAsUser\" with \"9\" argument(s): \"Failed to logon [Vagrant@speed.cs.nycu.edu.tw](mailto:Vagrant@speed.cs.nycu.edu.tw) (Logon failure: the user has not been granted the requested logon type at this computer, Win32ErrorCode 1385 - 0x00000569)\"\n    \n    解: 設定這兩個 GPO \n    \n    ![Untitled](Untitled%208.png)\n    \n    ![Untitled](Untitled%209.png)\n    \n    </aside>\n    \n5. 確認 ESC1HoneypotTemplate Template 是否被安裝\n    \n    ![Untitled](Untitled%2010.png)\n    \n    <aside>\n    💡 如果沒有可以試試手動 issue\n    \n    ![Untitled](Untitled%2011.png)\n    \n    ![Untitled](Untitled%2012.png)\n    \n    </aside>\n    \n6. 觀察 Bloodhound\n    - 在靶機上使用 Sharphound 來進行 AD graph 蒐集，然後匯入新版的 Bloodhound\n    - 可以觀察到 ADCSESC1 這條假 Edge 已經出現在 Bloodhound 內\n        \n        ![Untitled](Untitled%2013.png)\n        \n7. 使用 Certify 進行確認\n    - 在靶機上使用 Certify，並確認證書\n        \n        ```jsx\n        Certify.exe find /vulnerable\n        ```\n        \n        ![Untitled](Untitled%2014.png)\n        \n    - 使用 Certify 請求證書，如果 CA Response 為 Denied by Policy Module 表示成功安裝\n        \n        ![Untitled](Untitled%2015.png)\n        \n    💡 可用 **certutil.exe 找到 ca-name**\n    \n\n## Certiception 原理\n\n1. Certiception 會幫你自動創好一個 CA，但一個 Domain 內只有一個 CA，所以不能先有 ADCS\n2. ESC1HoneypotTemplate 確實是易受攻擊的證書，但使用 TameMyCerts 來阻止證書發放\n- 因為 ESC1 主要是利用 SAN，而 TameMyCerts 偵測到 request 包含 SAN 時就會取消\n    \n    ![螢幕擷取畫面 2024-07-22 220539.png](Untitled%2016.png)\n    \n3. 專案中使用 `ADCSTemplate` 來創建 Template，然後自動發放 ESC1HoneypotTemplate\n\n\n# **ESC1**\n\n- Misconfigured Certificate Templates - ESC1\n\n憑證範本有一組特定的設置，使它們極易被攻擊者利用，以實現網域權限提升。下面我們來介紹第一種配置情況（ESC1）：\n\n1. Enterprise CA 授予低特權使用者註冊權限\n2. Manager approval 被禁用\n3. 無需授權簽名\n4. 過於寬鬆的憑證範本安全描述符會授予低特權使用者憑證註冊權限。\n5. 憑證範本定義了啟用網域驗證的 EKU。\n6. 憑證範本允許請求者在 CSR 中指定 subjectAltName\n    - 這裡主要關注到最後一個配置條件。回想一下，在 AD 驗證期間，AD 將使用憑證的 subjectAltName（SAN）欄位指定身分。因此，如果請求者可以在 CSR 中指定 SAN，則請求者可以以任何人（例如，網域管理員使用者）的身分要求憑證。憑證範本在其 AD 物件的 mspki-certificate-name-flag 屬性中指定請求者是否可以在其中指定 SAN。 mspki-certificate-name-flag 屬性是位元掩碼，如果存在 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT 標誌，則請求者可以指定 SAN。在憑證範本控制台 MMC 管理單元中，此值在範本的 “屬性” 的 “使用者名稱” 標籤中進行設置，如下圖所示，勾選 “在要求中提供(S)” 即可。\n        \n        ![Untitled](Untitled%201.png)\n        \n        ![Untitled](Untitled%202.png)\n        ","tags":["Active Directory","ADCS"],"categories":["Active Directory"]},{"title":"使用Laravel Sanctum實作註冊登入登出","url":"/2021/01/25/2021-01-25-使用Laravel_Sanctum實作註冊登入登出/","content":"\nLaravel 7新增了Sanctum讓登入驗證流程更加方便，Sanctum不像passport要用到Oath2，而簡化了許多功能。比起passport，小應用或SPA更加適合使用Sanctum\n\n### 準備\n\n安裝sanctum\n``` bash\ncomposer require laravel/sanctum\n```\n\n發佈設定檔\n``` bash\nphp artisan vendor:publish --provider=\"Laravel\\Sanctum\\SanctumServiceProvider\"\n```\n\n建立資料庫\n``` bash\nphp artisan migrate\n```\n\n### Middleware設定\n\n我們要給Api設定Middleware才能跑登入流程，拿取使用者資料\n\n``` php\n//app/Http/Kernel.php\nuse Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful;\n\n'api' => [\n    EnsureFrontendRequestsAreStateful::class,\n    'throttle:60,1',\n    \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n],\n```\n\n### 註冊\n\n``` php\npublic function signUp(Request $request){\n    //驗證資料\n    $request->validate([\n        'name' => 'required',\n        'email' => 'required|email',\n        'password' => 'required',\n    ]);\n\n    //查詢是否存在\n    $user = User::where('email', $request->email)->first();\n    if ($user != null) {\n        $data = [\n            \"method\" => \"sign up\",\n            \"message\" => \"already sign\",\n        ];\n        return response()->json($data, 401);\n    }\n\n    //建立帳戶\n    $user = User::create([\n        'sign_up_date' => date('Y-m-d'),\n        'name' => $request['name'],\n        'email' => $request['email'],\n        'password' => bcrypt($request['password']),\n    ]);\n\n    if ($user != null) {\n        $data = [\n            \"method\" => \"sign up\",\n            \"message\" => \"success\",\n        ];\n        return response()->json($data, 200);\n    } else {\n        $data = [\n            \"method\" => \"sign up\",\n            \"message\" => \"unexpected error\",\n        ];\n        return response()->json($data, 500);\n    }\n}\n```\n\n### 登入\n\n``` php\npublic function getToken(Request $request){\n    //驗證資料\n    $request->validate([\n        'email' => 'required|email',\n        'password' => 'required',\n        'device_name' => 'required'\n    ]);\n\n    $user = User::where('email', $request->email)->first();\n\n    if (!$user || !Hash::check($request->password, $user->password)) {\n        $data = [\n            \"method\" => \"login\",\n            \"message\" => \"failed\",\n            \"data\" => [\n                \"access_token\" => \"\",\n                \"user_name\" => \"\",\n            ]\n        ];\n        return response()->json($data, 401);\n    } else {\n        $data = [\n            \"method\" => \"login\",\n            \"status_code\" => \"200\",\n            \"message\" => \"success\",\n            \"data\" => [\n                \"access_token\" => $user->createToken($request->device_name)->plainTextToken,\n                \"user_name\" => $user->name,\n            ]\n        ];\n        return response()->json($data, 200);\n    }\n}\n```\n\n### 登出\n\n``` php\npublic function deleteToken(Request $request){\n    $request->user()->tokens()->where('name', $request->device_name)->delete();\n}\n```\n\n如果使用Vue的話，可使用Vuex儲存token和不機密的使用者資料，也可為token設定範圍，區分管理者和用戶的權限。","tags":["Laravel","Vue","Sanctum"],"categories":["Laravel"]}]